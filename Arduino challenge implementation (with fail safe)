#include <Servo.h>
Servo leftservo;  
Servo rightservo;  
const int pingPin = 5; // Trigger Pin of Ultrasonic Sensor
const int echoPin = 6; // Echo Pin of Ultrasonic Sensor
float distance;
long duration;
int turn;

bool inRange(int val, int minimum, int maximum)
{
  return ((minimum <= val) && (val < maximum));
}
/*function which enables us to set a range of values, 
makes it so that we don't have to use && all the time*/

void take_dist() { //we can call this function whenever we want to take the distance from the wall
  //clear the ping pin
  digitalWrite(pingPin, LOW);
  delayMicroseconds(2);
  //send the 10 microsecond trigger
  digitalWrite(pingPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(pingPin, LOW);
  //get the pulse duration in microseconds
  duration = pulseIn(echoPin, HIGH);
  //calculate the distance
  distance = duration*0.034/2;
  Serial.print("Distance = ");
  Serial.print(distance);
  Serial.println(" cm");
  //print the distance
}

void turn_right() { //we can call this function to make the robot turn right
  leftservo.write(180);
  rightservo.write(60);
}

void turn_left() { //we can call this function to make the robot turn left
  leftservo.write(110);
  rightservo.write(0);
}

void forward() { //we can call this function to make the robot go forward
  leftservo.write(170);
  rightservo.write(10);
}

void backward() { //we can call this function to make the robot go backward
  leftservo.write(10);
  rightservo.write(170);
}

void stop() { //we can call this function to make the robot stop
  leftservo.write(90);
  rightservo.write(90);
}

//Main program:

void setup() {
  leftservo.attach(9);  
  rightservo.attach(10);
  //set up the Serial
  Serial.begin(9600);
  //setup the pin modes  
  pinMode(pingPin, OUTPUT);
  pinMode(echoPin, INPUT);
  leftservo.write(90);
  rightservo.write(90);
  turn = 0;
}

void loop() {

take_dist(); //measure the distance between the robot and the wall

if((distance < 30)&&(turn == 0)){
  turn_right();
  delay(400);
}
//if the distance is under 30 for wall A, then the robot has a net movement to the right

else if((inRange(distance, 30, 50))&&(turn == 0)){
  forward();
  delay(500);
}
//if the distance is between 30 and 50 for wall A, then the robot goes forward

else if((inRange(distance, 50, 100))&&(turn == 0)){
  turn_left();
  delay(400);
}
//if the distance is between 50 and 100 for wall A, then the robot has net movement to the left

else if((distance >= 500)&&(turn == 0)){
  forward();
  delay(100);
}

if((inRange(distance, 100, 500))&&(turn == 0)){

  while(true){ //when the robot reaches the gap, we enter a while loop
    forward();
    delay(2000);
    leftservo.write(180);
    rightservo.write(90);
    delay(400);
    take_dist();
    /*the robot adjusts its position and turns right, 
    this is so that it can take the distance from the wall on the right of the screen*/

    if(distance == 0){
      continue;
    }

    else if(distance <= 100){
      turn = 1;
      break;
    }
  }
}

if((distance < 30)&&(turn == 1)){
  turn_right();
  delay(400);
}
//if the distance is under 30 for wall B, then the robot has a net movement to the right

else if((inRange(distance, 30, 50))&&(turn == 1)){
  forward();
  delay(500);
}
//if the distance is between 30 and 50 for wall B, then the robot goes forward

else if((inRange(distance, 50, 150))&&(turn == 1)){
  turn_left();
  delay(400);
}
//if the distance is between 50 and 100 for wall B, then the robot has net movement to the left

else if((distance >= 500)&&(turn == 1)){
  forward();
  delay(100);
}

if((inRange(distance, 150, 500))&&(turn == 1)){

  while(true){ //when the robot reaches the gap, we enter a while loop
    leftservo.write(90);
    rightservo.write(0);
    delay(400);
    forward();
    delay(2000);
    take_dist();
    /*the robot adjusts its position and turns left, 
    this is so that it can take the distance from the wall on the right of the screen*/

    if(distance == 0){
      continue;
    }

    else if(distance <= 100){
      turn = 2;
      break;
    }
  }
}

if((distance < 30)&&(turn == 2)){
  turn_right();
  delay(400);
}
//if the distance is under 30 for wall C, then the robot has a net movement to the right

else if((inRange(distance, 30, 50))&&(turn == 2)){
  forward();
  delay(500);
}
//if the distance is between 30 and 50 for wall C, then the robot goes forward

else if((inRange(distance, 50, 100))&&(turn == 2)){
  turn_left();
  delay(400);
}
//if the distance is between 50 and 100 for wall C, then the robot has net movement to the left

else if((distance >= 500)&&(turn == 2)){
  forward();
  delay(100);
}

}