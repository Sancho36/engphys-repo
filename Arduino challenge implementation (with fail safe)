#include <Servo.h>
Servo leftservo;  
Servo rightservo;  
const int pingPin = 5; // Trigger Pin of Ultrasonic Sensor
const int echoPin = 6; // Echo Pin of Ultrasonic Sensor
float distance;
long duration;
int turn; //indicates the turn number, helps the robot know where it is

/*function which enables us to set a range of values, 
makes it so that we don't have to use && all the time*/
bool inRange(int val, int minimum, int maximum)
{
  return ((minimum <= val) && (val < maximum));
}

void take_dist() { //we can call this function whenever we want to take the distance from the wall
  //clear the ping pin
  digitalWrite(pingPin, LOW);
  delayMicroseconds(2);
  //send the 10 microsecond trigger
  digitalWrite(pingPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(pingPin, LOW);
  //get the pulse duration in microseconds
  duration = pulseIn(echoPin, HIGH);
  //calculate the distance
  distance = duration*0.034/2;
  Serial.print("Distance = ");
  Serial.print(distance);
  Serial.println(" cm");
  //print the distance
}

void turn_right() { //we can call this function to make the robot turn right
  leftservo.write(180);
  rightservo.write(57);
  Serial.print("-> turning right ");
}

void turn_left() { //we can call this function to make the robot turn left
  leftservo.write(110);
  rightservo.write(0);
  Serial.print("-> turning left ");
}

void forward() { //we can call this function to make the robot go forward
  leftservo.write(115);
  rightservo.write(0);
  Serial.print("-> going forward ");
}

void backward() { //we can call this function to make the robot go backward
  leftservo.write(10);
  rightservo.write(170);
}

void stop() { //we can call this function to make the robot stop
  leftservo.write(90);
  rightservo.write(90);
}

//Main program:

void setup() {
  leftservo.attach(9);  
  rightservo.attach(10);
  //set up the Serial
  Serial.begin(9600);
  //setup the pin modes  
  pinMode(pingPin, OUTPUT);
  pinMode(echoPin, INPUT);
  leftservo.write(90);
  rightservo.write(90);
  turn = 0; //initially, the robot has completed 0 turns
}

void loop() {

take_dist(); //measure the distance between the robot and the wall

//if the distance is under 49 for wall 1, then the robot has a net movement to the right
if((inRange(distance, 5, 45))&&(turn == 0)){
  turn_right();
  delay(100);
}

else if((distance < 5)&&(turn == 0)){
  stop();
  delay(300);
}

//if the distance is between 49 and 50 for wall 1, then the robot goes forward
else if((inRange(distance, 45, 55))&&(turn == 0)){
  forward();
  delay(200);
}

//if the distance is between 50 and 150 for wall 1, then the robot has net movement to the left
else if((inRange(distance, 55, 150))&&(turn == 0)){
  turn_left();
  delay(200);
}

/*fail-safe wall 1 in case the robot has an issue 
(usually, when the sensor does not register a distance correctly, it defaults to something close to 1189 cm)*/
else if((distance >= 400)&&(turn == 0)){
  Serial.println("Enacted fail-safe 1");
  forward();
  delay(200);
}

//if the distance is between 150 and 400 for wall 1, then the robot knows it has reached the first turn
if((inRange(distance, 150, 400))&&(turn == 0)){

  while(true){ //when the robot reaches the gap, we enter a while loop
    /*the robot adjusts its position and turns right, 
    this is so that it can take the distance from wall 2*/
    forward();
    delay(2500);
    leftservo.write(180);
    rightservo.write(90);
    delay(500);
    take_dist();

    //fail-safe in case the sensor has an error and registors a distance of 0 cm
    if(distance == 0){
      continue;
    }
    
    /*fail-safe in case the sensor registers an odd value,
    we are fairly confident in this part, so if such a case */
    else if(distance >= 400){
      turn = 1;
      Serial.println("Turn 1 completed");
      break;
    }
      
    else if(distance <= 150){
      turn = 1;
      Serial.println("Turn 1 completed");
      break;
    }
  }
}

//if the distance is under 30 for wall 2, then the robot has a net movement to the right
if((distance < 34)&&(turn == 1)){
  turn_right();
  delay(100);
}

//if the distance is between 30 and 50 for wall 2, then the robot goes forward
else if((inRange(distance, 34, 35))&&(turn == 1)){
  forward();
  delay(100);
}

//if the distance is between 50 and 150 for wall 2, then the robot has net movement to the left
else if((inRange(distance, 35, 150))&&(turn == 1)){
  turn_left();
  delay(100);
}

//fail-safe wall 2
else if((distance >= 400)&&(turn == 1)){
  Serial.println("Enacted fail-safe 2");
  forward();
  delay(100);
}

//if the distance is between 150 and 500 for wall 2, then the robot knows it has reached the second turn
if((inRange(distance, 60, 400))&&(turn == 1)){

  while(true){ //when the robot reaches the gap, we enter a while loop
    /*the robot adjusts its position and turns left, 
    this is so that it can take the distance from the wall on the right of the screen*/
    forward();
    delay(600);
    leftservo.write(90);
    rightservo.write(0);
    delay(500);
    forward();
    delay(2000);
    take_dist();

    if(distance == 0){
      continue;
    }

    else if(distance >= 400){
      turn = 2;
      Serial.println("Turn 2 completed");
      break;
    }

    else if(distance <= 100){
      turn = 2;
      Serial.println("Turn 2 completed");
      break;
    }
  }
}

//if the distance is under 30 for wall 3, then the robot has a net movement to the right
if((distance < 24)&&(turn == 2)){
  turn_right();
  delay(100);
}

//if the distance is between 30 and 50 for wall 3, then the robot goes forward
else if((inRange(distance, 24, 25))&&(turn == 2)){
  forward();
  delay(100);
}

//if the distance is between 50 and 150 for wall 3, then the robot has net movement to the left
else if((inRange(distance, 25, 150))&&(turn == 2)){
  turn_left();
  delay(100);
}

//fail-safe wall 3
else if((distance >= 400)&&(turn == 2)){
  Serial.println("Enacted fail-safe 3");
  forward();
  delay(100);
}

}